var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { useEffect, useRef } from "react";
import useWavesurferContext from "../hooks/useWavesurferContext";
// TODO: remove boilerplate in useEffects section, try to update useRegionEvent to support
//  all kinds of event handling within WaveSurfer ecosystem
export default function Marker(_a) {
    var { onClick, onDrop, onDrag } = _a, data = __rest(_a, ["onClick", "onDrop", "onDrag"]);
    const ws = useWavesurferContext();
    // TODO: make some kind of useGetLatestWs...
    const ws$ = useRef(ws);
    useEffect(() => {
        ws$.current = ws;
    }, [ws]);
    // This is the only legal/official way to identify marker
    // inside wavesurfer markers list and
    // to tie it with Marker component
    const isRendered = useRef(false);
    const markerEl = useRef(null);
    useEffect(() => {
        if (!ws)
            return;
        if (!onClick)
            return;
        function handler(marker, event) {
            if (!markerEl.current)
                return;
            if (marker.el !== markerEl.current.el)
                return;
            onClick === null || onClick === void 0 ? void 0 : onClick(marker, event);
        }
        ws.on("marker-click", handler);
        return () => {
            ws.un("marker-click", handler);
        };
    }, [ws, onClick]);
    useEffect(() => {
        if (!ws)
            return;
        if (!onDrag)
            return;
        function handler(marker, event) {
            if (!markerEl.current)
                return;
            if (marker.el !== markerEl.current.el)
                return;
            onDrag === null || onDrag === void 0 ? void 0 : onDrag(marker, event);
        }
        ws.on("marker-drag", handler);
        return () => {
            ws.un("marker-drag", handler);
        };
    }, [ws, onDrag]);
    useEffect(() => {
        if (!ws)
            return;
        if (!onDrop)
            return;
        function handler(marker, event) {
            if (!markerEl.current)
                return;
            if (marker.el !== markerEl.current.el)
                return;
            onDrop === null || onDrop === void 0 ? void 0 : onDrop(marker, event);
        }
        ws.on("marker-drop", handler);
        return () => {
            ws.un("marker-drop", handler);
        };
    }, [ws, onDrop]);
    useEffect(() => {
        if (!ws)
            return;
        // THERE CAN BE ONLY ONE
        // ...
        // ...
        // ...
        // marker creation for each Marker component.
        // If there is a better way, PRs welcome!
        if (isRendered.current)
            return;
        isRendered.current = true;
        // create marker: marker becomes visible at the same time
        markerEl.current = ws.addMarker(data);
    }, [ws]);
    useEffect(() => {
        var _a;
        if (!ws || !markerEl.current || !isRendered.current)
            return;
        // Проверяем что изменения реально имели место быть,
        // но снаружи, а не внутри
        // На данный момент, меняется только позиция
        if (data.time === ((_a = markerEl.current) === null || _a === void 0 ? void 0 : _a.time))
            return;
        // When wavesurfer will officially make markers fully updatable,
        // then it will be done in other way, for now it's enough.
        //
        // For enthusiasts, it is possible to deep dive into the process of marker creation and make a PR,
        // that will add full marker update support.
        // https://wavesurfer-js.org/api/file/src/plugin/markers/index.js.html
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const marker = ws.markers.markers.find(mark => { var _a; return mark.el === ((_a = markerEl.current) === null || _a === void 0 ? void 0 : _a.el); });
        if (!marker)
            return;
        marker.time = data.time;
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        ws.markers._updateMarkerPosition(Object.assign(Object.assign({}, markerEl.current), { time: data.time }));
    }, [data === null || data === void 0 ? void 0 : data.time]);
    // Maybe it will require to create some single source of truth for Markers,
    // as far as they are working via wavesurfer instance. That's making'em
    // different from Regions in the way of working.
    useEffect(() => () => {
        if (!ws$.current || !markerEl.current)
            return;
        const index = ws$.current.markers.markers.findIndex((marker) => {
            var _a;
            return marker.el === ((_a = markerEl.current) === null || _a === void 0 ? void 0 : _a.el);
        });
        ws$.current.markers.remove(index);
    }, []);
    return null;
}
